import {async, ComponentFixture, TestBed} from '@angular/core/testing';

import {InputComponent} from './input.component';

/*describe('InputComponent', () => {
	let component: InputComponent;
	let fixture: ComponentFixture<InputComponent>;

	beforeEach(async(() => {
		TestBed.configureTestingModule({
			declarations: [InputComponent]
		}).compileComponents();

		fixture   = TestBed.createComponent(InputComponent);
		component = fixture.componentInstance;
		fixture.detectChanges();
	}));

	it('InputComponent should be created', () => {
		expect(component).toBeTruthy();
	});

	/!*it('should have the message defined as empty string', () => {
		expect(fixture.debugElement.nativeElement.innerHTML).toContain('');
	});*!/

	/!*it('should have the message defined ', () => {
		// now let's set the message
		component.msg = 'Hi, there';

		// If the line is commented, no change detection is fired. Angular will NOT
		// know that the template has changed. Use fixture.detectChanges() to tell Angular
		// to update the DOM.
		// fixture.detectChanges();

		// working with debugElement (recommended)
		const text = fixture.debugElement.nativeElement.innerHTML;

		// working with nativeElement (not recommended, but a valid option)
		// const text = fixture.nativeElement.querySelector('p').innerHTML;
		expect(text).toContain('Hi, there');


		// if you *always* want Angular testing to automatically detect changes (not recommended, b/c of performance issues), use
		// you can use ComponentFixtureAutoDetect. See https://angular.io/guide/testing#automatic-change-detection for more information.
	})*!/
});*/
